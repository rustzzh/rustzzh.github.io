<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>共识算法Raft简介 - zh's blog</title><meta name=Description content="简单介绍共识算法Raft如何在分布式系统中达成共识。"><meta property="og:title" content="共识算法Raft简介"><meta property="og:description" content="简单介绍共识算法Raft如何在分布式系统中达成共识。"><meta property="og:type" content="article"><meta property="og:url" content="https://rustzzh.github.io/posts/raft_intro/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-28T16:51:46+08:00"><meta property="article:modified_time" content="2022-05-02T08:31:53+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="共识算法Raft简介"><meta name=twitter:description content="简单介绍共识算法Raft如何在分布式系统中达成共识。"><meta name=application-name content="zh's blog"><meta name=apple-mobile-web-app-title content="zh's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://rustzzh.github.io/posts/raft_intro/><link rel=prev href=https://rustzzh.github.io/posts/first_blog/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"共识算法Raft简介","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/rustzzh.github.io\/posts\/raft_intro\/"},"genre":"posts","keywords":"raft, consensus","wordcount":5724,"url":"https:\/\/rustzzh.github.io\/posts\/raft_intro\/","datePublished":"2022-04-28T16:51:46+08:00","dateModified":"2022-05-02T08:31:53+00:00","publisher":{"@type":"Organization","name":"zh"},"author":{"@type":"Person","name":"zh"},"description":"简单介绍共识算法Raft如何在分布式系统中达成共识。"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":''==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:''==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="zh's blog">zh's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="zh's blog">zh's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">共识算法Raft简介</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>zh</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/distributed-system/><i class="far fa-folder fa-fw"></i>distributed system</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-04-28>2022-04-28</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5724 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 12 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-分布式系统>1 分布式系统</a><ul><li><a href=#11-简介>1.1 简介</a></li><li><a href=#12-解法>1.2 解法</a></li></ul></li><li><a href=#2-分布式共识>2 分布式共识</a><ul><li><a href=#21-raft算法概述>2.1 Raft算法概述</a><ul><li><a href=#211-领导选举>2.1.1 领导选举</a></li><li><a href=#212-日志复制>2.1.2 日志复制</a></li><li><a href=#213-安全性>2.1.3 安全性</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=1-分布式系统>1 分布式系统</h1><h2 id=11-简介>1.1 简介</h2><p>分布式系统指的是一组通过网络通信的、为了完成共同的任务而协调工作的计算机节点组成的系统。
这个定义很好地概括的分布式系统的特点：<strong>基于网络的</strong>、<strong>协同工作</strong>。
从系统内部看，系统由一系列网络上分布的计算机节点协同工作；从系统外部看，分布式系统像一个单一节点对外提供服务。
不同的计算机节点可能分布在不同的地理区域，也可能坐落在同一台机架，甚至可能通过docker部署在同一台物理机上。
因此分布式系统并不是特指在地理上分布，而是在网络中分布。</p><p>因为早期的计算机系统性能特别的差，科学家们尝试组合使用多台计算机来获得更好的性能。
遇到的第一个问题就是计算机之间如何通信，如何让机器A调用机器B上的程序？</p><p>一个简单的想法是想要像本地调用程序一样调用远程服务。在Go语言中用来排序的函数Sort在调用的时候会涉及到如下几个概念。在写出类似 <code>sortedSlice = Sort(unsortedSlice)</code> 这样的代码时，有几个问题需要解决：</p><ol><li><p>传递方法参数：例如在这个函数中，传入的参数是一个int类型的数组，在本地调用时将其压栈</p></li><li><p>确定方法版本：在不同的语言版本中会出现名字相同的函数，在调用的时候编译器会确定调用函数的版本。</p></li><li><p>执行：执行相应的函数。</p></li><li><p>返回执行结果：这里的返回结果是一个int类型的数组，在调用结束后，将结果压栈，将程序恢复到Call Site继续执行。</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// Caller     : 调用者
</span></span></span><span class=line><span class=cl><span class=c1>// Callee     : 被调用者
</span></span></span><span class=line><span class=cl><span class=c1>// Call Site  : 调用点
</span></span></span><span class=line><span class=cl><span class=c1>// Parameter  : 参数
</span></span></span><span class=line><span class=cl><span class=c1>// Retval     : 返回值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Sort</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=nx>b</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=c1>// some logical code
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=o>...</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到在整个程序的调用过程中利用了一个共享的栈，在远程过程调用（RPC）中，存在全局的共享栈，因此如何实现第一步和第四步是一个需要考虑的问题。
其次在第二步确认方法版本的时候，当调用者与被调用者不是相同版本的同一语言，甚至是不同的语言的时候，如何确定方法的版本也是一个问题。</p><p>除了如何让不同的机器相互调用以外，还需要认识到一个问题：网络是不可靠的。
网络中的数据包可能丢失，可能出现乱序，可能出现重复，可能出现网络分区等等问题。
如何让系统在不可靠的网络中表现确定的行为也是需要仔细对待的问题。
例如在一个领导者-追随者模型中，如果发生了网络分区，出现两个领导者同时向外提供服务的时候，整个集群表现为脑裂，集群进入到不一致的状态。</p><p>除了网络问题之外，还需要考虑到硬件故障，在硬件发生故障的时候如何区分、如何在故障的基础上仍然保持系统是可用的状态等等。</p><h2 id=12-解法>1.2 解法</h2><p>这一节负责对上一节提出的分布式系统需要处理的几个主要问题简单介绍目前通用的解法，更加详细的叙述留在之后的章节中展开。</p><p><strong>远程过程调用(Remote Procedure Call)</strong>：上一节提到远程过程调用需要着重解决三个基本问题，即传递方法参数、确认方法版本、返回执行结果。
这三个问题目前可以通过序列化/反序列化+传输的方式解决，本文以protobuf为例进行说明。
序列化指的是，在请求端将需要传输的对象（参数，方法名等）转换成二进制，反序列化则是指在服务端将传输过来的二进制转换成相应的对象进行调用。
protobuf通过接口定义语言(Interface Definition Language)为相应的方法定义参数和返回值，并在其中指定方法的相应版本。
通过这一套编解码方式能够基本解决一个方法调用中遇到的三个基本问题，除此之外还需要在网络中进行传输。
为了保证通信的可靠，RPC一般将通信建立在TCP之上。通过序列化/反序列化+传输的方式能够实现出通用的RPC框架用于进行RPC调用。</p><p><strong>共识算法</strong>：在单体系统中错误的监控与排查思路非常清晰，机器出故障了就停机维修，网络中断了也能够从请求、响应中观测到。
但是在分布式系统中，外部看起来一样的表现可能对应多个不同的内部状态。例如一个请求没有响应有可能是网络丢包，可能是机器宕机，也可能发生了网络分区。
为了让多台机器对外表现得像同一台机器，需要让多个机器达成共识。共识通常指的是如何确定一组分布式节点之间的有序值的序列问题，即一系列操作发生的顺序。
在共识的基础上引入状态机。一个显而易见的结论是，如果一组状态机的开始状态是相同的，经过相同顺序的一系列状态变更后，这一组状态机的结束状态也应该是相同的。
通过复制状态机加上共识算法能够保证一组机器在一系列操作后表现出一致的状态。</p><p>那么如何利用共识来解决之前提到的网络、硬件问题？</p><p>首先是对同一个集群引入多台机器，机器间通过复制状态机加共识算法来保持一致。其次是对于网络操作可能出现的问题，状态机要能够有相应的容错能力。这一点会在第二章对Raft的叙述中详细展开。</p><p>至此，通过使用RPC和共识算法，能够搭建出在硬件一定会发生故障、网络不可靠的环境下的可靠的分布式系统，后文将会依据这两点来构建分布式键值存储系统。</p><h1 id=2-分布式共识>2 分布式共识</h1><p>分布式共识通常指的是如何确定一组分布式节点之间的有序值的序列问题，即一系列操作发生的顺序。
本章将介绍Raft算法如何实现分布式共识。</p><h2 id=21-raft算法概述>2.1 Raft算法概述</h2><p>一个共识算法基本构成如图2.1所示，图中展示了两种进程，分别是client端和server端，其中client端可以简单理解为分布式系统外部的调用，server端理解为分布式系统内部节点。
其中每一片都表示不同的进程，系统整体的架构由如图所示的多客户端、多服务端组成。</p><p><figure><a class=lightgallery href=/images/raft.png title=共识算法整体架构 data-thumbnail=/images/raft.png data-sub-html="<h2>共识算法整体架构</h2><p>共识算法整体架构</p>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/raft.png data-srcset="/images/raft.png, /images/raft.png 1.5x, /images/raft.png 2x" data-sizes=auto alt=/images/raft.png></a><figcaption class=image-caption>共识算法整体架构</figcaption></figure></p><p>其中服务端可以粗略划分为两个模块：共识模块和状态机。
其中共识模块用于实现包括日志记录、日志同步、领导选举等操作以实现分布式共识；状态机模块将达成共识的日志应用到状态机，从而在外部看来系统呈现出一致的状态。
在这里共识模块指的是以Raft论文为模版实现的共识代码库，状态机指的是键值存储系统，Log部分也由共识模块进行管理。</p><p>一次对由共识算法组织起来的复制状态机的操作如图上序号所示：</p><ol><li><p>客户端向服务端发出请求。在Raft中，请求由领导者进行处理，如果请求发送到了追随者，将会被撞发到领导者进行相应的处理。
关于集群中服务端的身份说明会在接下来展开介绍。</p></li><li><p>领导者收到请求后会将操作转化成相应的日志加入到当前日志模块中，并且会将其同步给集群中的其他追随者，这两步没有严格的先后顺序，可以先发送再落盘，也可以并行进行。</p></li><li><p>在日志被复制到集群中大多数(majority, 3 in 5, 2 in 3)机器后，这条日志的状态将标记为提交(committed)，提交的日志随后将发到状态机中进行应用(apply)。</p></li><li><p>当一条日志被应用之后，其结果可以认为在集群中达成共识，此时服务端可以向客户端返回操作的结果。</p></li></ol><p>Raft将共识问题拆成三个子问题，通过解决三个子问题来对集群中的节点的状态达成共识：</p><ol><li><p>领导选举：集群中的节点有三种状态，领导者、候选人、追随者。
集群中的领导者是唯一对外接受操作指令的节点，使整个集群对外呈现出单节点的特性。
所有的客户端的请求都直接发给领导者，领导者负责执行操作。
追随者没有主动的动作，只响应候选者和领导者的RPC请求。
候选者只有一个动作就是征集选票，当收到的选票数据超过集群一半（majority）的时候，候选者晋升为领导者，负责响应外部操作。
状态转划图如图2.2所示。</p></li><li><p>日志复制：领导者将会对来自客户端的操作生成日志条目，并负责将日志条目同步到集群中的其他节点。</p></li><li><p>安全性：如果某一个节点已经将某一个确定索引的日志提交到状态机中进行应用了，那么将不会有其他的节点提交相同索引的另一条日志到状态机中应用。</p></li></ol><p><figure><a class=lightgallery href=/images/kt_1.png title=状态转换图 data-thumbnail=/images/kt_1.png data-sub-html="<h2>节点状态转换图</h2><p>状态转换图</p>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/kt_1.png data-srcset="/images/kt_1.png, /images/kt_1.png 1.5x, /images/kt_1.png 2x" data-sizes=auto alt=/images/kt_1.png></a><figcaption class=image-caption>节点状态转换图</figcaption></figure></p><p>Raft需要始终保持如下五条特性：</p><ol><li><p>选举安全性：在一个任期内最多有一个领导者。</p></li><li><p>领导者对日志的操作为只添加：领导者永远不会删除或覆盖本地的日志数据，领导者对日志的写操作只能是添加(Append-only)。</p></li><li><p>日志匹配性：如果两个节点上的日志在某个确定索引上的任期号相同，那么在这个索引之前的所有日志都是相同的。</p></li><li><p>领导者完备性：如果一条日志在某个任期被提交，这条日志在更高任期的领导者的日志数据中应该存在。</p></li><li><p>状态机安全性：如果某一个节点已经将某一个确定索引的日志提交到状态机中进行应用了，那么将不会有其他的节点提交相同索引的另一条日志到状态机中应用。</p></li></ol><p>接下来将对Raft要解决的三个子问题分节论述。</p><h3 id=211-领导选举>2.1.1 领导选举</h3><p>在Raft中使用时期(Term)作为整个系统的逻辑时钟，时期是单调递增的。</p><p>在Raft中每一个新启动的节点都是追随者状态，每个节点都会有两个超时时间，一个是选举超时时间，另一个是心跳时间。
领导者通过发送心跳信息维持其统治地位，心跳时间是领导者向追随者发送心跳信息的间隔。
选举超时时间是指，在每个选举超时时间间隔中，如果没有收到来自领导者的心跳信息、日志复制请求，即认为集群当前时期领导者已经失位，自己可以变成候选者发起选举尝试成为领导者，当收到集群中大多数节点的选票后，候选者会成为领导者。</p><p>如果在选举超时时间内候选者没能收集到大多数节点的选票，同时也没有收到来自当前时期的其他节点的心跳信息的时候将会开启新一轮的选举。</p><p>每个节点会给最先收到的征集选票的请求投票，每个时期只会给一个候选人投票，不同的候选人通过ID标识自己。</p><p>为了降低选票平分现象的频率，每个节点初始时候设置的选举超时时间会在一个范围内随机，例如150～300ms，并且集群中节点的个数会设置为2n+1，常见为五节点集群，这样的集群能够忍受两个节点的崩溃。</p><p>下面用伪代码将上述过程描述出来：</p><pre tabindex=0><code>// 每个新启动的节点初始状态为追随者，设置选举超时时间为150～300ms

节点主循环：
   选举超时时间到：
      如果没有收到来自领导者的心跳信息：
         Term++
         将状态设置为候选人
         开始一轮选举

   心跳时间到：
      如果节点状态是领导者：
         向集群内所有节点发送心跳信息   

收到征集选票请求的处理(RequestVoteRPC)：
   如果征集选票的请求附带的时期小于当前节点的时期：
      投反对票
      返回
   如果征集选票的请求附带的日志信息不符合选举限制（限制的具体内容将在安全性一节介绍）：
      投反对票
      返回
   投同意票
   将需要记录的状态进行保存（将在2.2节实现中介绍）
   返回

对选票返回值的处理(RespHandler)：
   如果收到的是同意票：
      agreeNum++
      如果agreeNum &gt; majority：
         晋升为领导者
         向集群中其他节点发送一条no-op的日志信息以确保安全性（具体内容将在2.1.3中讨论）
   如果返回值中的Term大于当前节点的Term：
      更新自身的Term
      退化为追随者
</code></pre><h3 id=212-日志复制>2.1.2 日志复制</h3><p>前面提到，来自客户端的请求会被领导者转换成日志的形式添加到本地日志中，随后将同步给集群中的所有节点，当大多数节点接收到这条日志以后，可以认为这条日志已提交，并可以安全应用到状态机中。这一节介绍日志如何复制到集群中其他节点。</p><p>每一条日志可以定义成一个简单的三元组(时期，索引，操作），时期和索引是领导者为客户端的一次操作请求生成的，其中索引是单调递增的，可以简单理解为日志被数组所管理，索引标识日志在数组中的位置。</p><p>日志复制操作是第一个涉及到状态机和共识算法库交互的操作，共识算法库需要提供一个接口给状态机让其将需要同步的日志传输给共识库，通过图例来简单说明一次日志同步的流程：</p><p><figure><a class=lightgallery href=/images/log_replicate.jpg title=日志复制流程图 data-thumbnail=/images/log_replicate.jpg data-sub-html="<h2>日志复制流程图</h2><p>日志复制流程图</p>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/log_replicate.jpg data-srcset="/images/log_replicate.jpg, /images/log_replicate.jpg 1.5x, /images/log_replicate.jpg 2x" data-sizes=auto alt=/images/log_replicate.jpg></a><figcaption class=image-caption>日志复制流程图</figcaption></figure></p><ol><li><p>客户端发起一次请求将x的值设置为1，首先请求会被路由到集群中的领导者的状态机，状态机将操作转化成一条日志发送给共识库，随后等待共识库将其应用到状态机，应用后返回给客户端。</p></li><li><p>共识库收到新增的日志后首先添加到本地日志中，随后通过AppendEntryRPC请求将日志发送给集群中的其他节点。</p></li><li><p>其他节点收到日志后也将日志添加到日志库中，添加成功则返回OK。</p></li><li><p>当领导者观测到集群中大多数节点都已经成功将一条日志添加到日志库之后，会将这条日志标记为已提交，已提交的日志可以返回给状态机应用。随后状态机将操作结果返回给客户端。</p></li><li><p>集群中的其他追随者会在之后的AppendEntry请求中获得当前领导者已提交的日志索引信息，随后更新自己的已提交日志索引信息。
如果更新后日志索引信息大于当前已应用的最大日志索引，将会把新的可以应用的日志推给状态机应用。随后领导者和追随者的复制状态机状态相同。</p></li></ol><h3 id=213-安全性>2.1.3 安全性</h3><p>为了确保安全性，Raft特别强调了两种情况，分别是选举限制和提交前面任期的条目。</p><p><strong>选举限制</strong>：并不是所有的征集选票的请求都能收到赞同票。只有发出请求的节点的时期不小于当前节点，且当前节点在该时期没有给其他节点投赞同票，且发出请求的节点的日志信息至少和当前节点一样新，当前节点才会给发出请求的节点投票。
如何定义一样新？每一条日志都有一个时期和索引，比较两份日志谁更新的方式是比较两份日志的最后一条日志，如果最后一条日志的时期不同，那么时期更大的那一份日志更新；如果时期相同，那么索引更大的那一份日志更新。</p><p><strong>提交前面任期的条目</strong>：当一个节点新上任领导者的时候可能出现一种情况就是，当前日志中有上一时期未提交的日志条目，能否对这个条目进行提交？结论是不行，以图为例进行说明：</p><p><figure><a class=lightgallery href=/images/commit_before.png title=不能提交之前任期的日志 data-thumbnail=/images/commit_before.png data-sub-html="<h2>不能提交之前任期的日志</h2><p>不能提交之前任期的日志</p>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/commit_before.png data-srcset="/images/commit_before.png, /images/commit_before.png 1.5x, /images/commit_before.png 2x" data-sizes=auto alt=/images/commit_before.png></a><figcaption class=image-caption>不能提交之前任期的日志</figcaption></figure></p><ol><li>图a中S1是领导者，添加了时期为2的日志并复制到了S2</li><li>图b中S1崩溃，S5被选为领导者并添加了一条日志，时期为3，随后崩溃</li><li>图c中，S1又晋升为领导者，添加了一条时期为4的日志，到这里可能出现两种情况<ol><li>如图e所示，S1没有崩溃，并且将时期为4的日志复制到了集群中的大多数节点</li><li>如图d所示，S1崩溃，S5重新当选，并将时期为3的日志复制到了集群中的所有节点</li></ol></li></ol><p>可以看出，如果S1在图c的时候，已经将时期为2的日志复制到大多数节点的情况下，就将这条日志提交的话，在随后崩溃，可能会出现“已提交的日志被覆盖”的情况，这违反了Raft需要满足的特性，因为状态机随后会将已提交的日志应用，但是随后又会出现一条时期为5，索引为2的日志尝试应用到相同的索引。</p><p>因此Raft禁止领导者提交之前时期的日志，只能提交在其任期内的日志。而日志是和来自客户端的操作相关的，如果在长时间内客户端没有请求任何操作，可能会出现已经复制到大多数机器的日志无法提交的状况，这种情况称为liveness问题。
为了避免之前任期的日志被这种请求阻塞，新上任的节点会立即同步一条空日志，目的是将之前任期未提交的日志全部提交，解决liveness问题。</p><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>参考<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p><a href=https://icyfenix.cn/architect-perspective/general-architecture/api-style/rpc.html#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1 target=_blank rel="noopener noreffer">凤凰架构</a></p><p><a href=https://www.codedump.info/post/20180921-raft/ target=_blank rel="noopener noreffer">Raft算法原理</a></p><p><a href=https://raft.github.io/raft.pdf target=_blank rel="noopener noreffer">In Search of an Understandable Consensus Algorithm</a></p></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-05-02</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/raft/>raft</a>,&nbsp;<a href=/tags/consensus/>consensus</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/first_blog/ class=prev rel=prev title=在这停顿><i class="fas fa-angle-left fa-fw"></i>在这停顿</a></div></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk></a>Gitalk</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.98.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>zh</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/gitalk/gitalk.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><script type=text/javascript src=/lib/gitalk/gitalk.min.js></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{gitalk:{admin:["rustzzh"],clientID:"da0c5fc5ea73e5fd68b1",clientSecret:"b109d474223d93fb730ca7e01f2b4d0d63fcc60d",id:"2022-04-28T16:51:46+08:00",owner:"rustzzh",repo:"rustzzh.github.io",title:"共识算法Raft简介"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>