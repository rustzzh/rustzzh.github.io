<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>[tran]关系型数据库原理 - zh's blog</title><meta name=Description content="(WIP)通过翻译这篇文章达到精读一遍的效果"><meta property="og:title" content="[tran]关系型数据库原理"><meta property="og:description" content="(WIP)通过翻译这篇文章达到精读一遍的效果"><meta property="og:type" content="article"><meta property="og:url" content="https://rustzzh.github.io/posts/tran-how-rdbms-works/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-09T17:35:56+08:00"><meta property="article:modified_time" content="2022-05-11T01:46:52+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[tran]关系型数据库原理"><meta name=twitter:description content="(WIP)通过翻译这篇文章达到精读一遍的效果"><meta name=application-name content="zh's blog"><meta name=apple-mobile-web-app-title content="zh's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://rustzzh.github.io/posts/tran-how-rdbms-works/><link rel=prev href=https://rustzzh.github.io/posts/cmu15445-db-storage/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"[tran]关系型数据库原理","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/rustzzh.github.io\/posts\/tran-how-rdbms-works\/"},"genre":"posts","keywords":"db, rdbms","wordcount":4175,"url":"https:\/\/rustzzh.github.io\/posts\/tran-how-rdbms-works\/","datePublished":"2022-05-09T17:35:56+08:00","dateModified":"2022-05-11T01:46:52+00:00","publisher":{"@type":"Organization","name":"zh"},"author":{"@type":"Person","name":"zh"},"description":"(WIP)通过翻译这篇文章达到精读一遍的效果"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":''==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:''==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="zh's blog">zh's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/friend/>友链 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="zh's blog">zh's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/friend/ title>友链</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">[tran]关系型数据库原理</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>zh</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-05-09>2022-05-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4175 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 9 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-回顾基础>1 回顾基础</a><ul><li><a href=#11-o1-vs-on2>1.1 $O(1)$ vs $O(n^2)$</a><ul><li><a href=#111-概念>1.1.1 概念</a></li><li><a href=#112-例子>1.1.2 例子</a></li><li><a href=#113-更深入一点>1.1.3 更深入一点</a></li></ul></li><li><a href=#12-归并排序>1.2 归并排序</a><ul><li><a href=#121-合并>1.2.1 合并</a></li><li><a href=#122-分治过程>1.2.2 分治过程</a></li><li><a href=#123-排序过程>1.2.3 排序过程</a></li><li><a href=#124-归并排序的强大之处>1.2.4 归并排序的强大之处</a></li></ul></li><li><a href=#13-数组树和哈希表>1.3 数组，树和哈希表</a><ul><li><a href=#131-数组>1.3.1 数组</a></li><li><a href=#132-树和数据库索引>1.3.2 树和数据库索引</a></li><li><a href=#133-哈希表>1.3.3 哈希表</a></li></ul></li></ul></li><li><a href=#2-全局概述>2 全局概述</a></li><li><a href=#3-客户端管理>3 客户端管理</a></li><li><a href=#4-查询管理>4 查询管理</a><ul><li><a href=#41-查询解析>4.1 查询解析</a></li><li><a href=#42-查询重写>4.2 查询重写</a></li><li><a href=#43-统计信息>4.3 统计信息</a></li><li><a href=#44-查询优化器>4.4 查询优化器</a><ul><li><a href=#441-索引>4.4.1 索引</a></li><li><a href=#442-访问路径>4.4.2 访问路径</a></li><li><a href=#443-联结操作>4.4.3 联结操作</a></li><li><a href=#444-简化的案例>4.4.4 简化的案例</a></li><li><a href=#445-动态规划贪心算法和启发式>4.4.5 动态规划、贪心算法和启发式</a></li><li><a href=#446-真正的优化器unimportant-part>4.4.6 真正的优化器(unimportant part)</a></li><li><a href=#447-查询计划缓存>4.4.7 查询计划缓存</a></li></ul></li><li><a href=#45-查询执行>4.5 查询执行</a></li></ul></li><li><a href=#5-数据管理>5 数据管理</a><ul><li><a href=#51-缓存管理>5.1 缓存管理</a><ul><li><a href=#511-预取>5.1.1 预取</a></li><li><a href=#512-缓存替换策略>5.1.2 缓存替换策略</a></li><li><a href=#513-写缓存>5.1.3 写缓存</a></li></ul></li><li><a href=#52-事务管理>5.2 事务管理</a><ul><li><a href=#521-酸了>5.2.1 酸了</a></li><li><a href=#522-并发控制>5.2.2 并发控制</a></li><li><a href=#523-锁管理>5.2.3 锁管理</a></li><li><a href=#524-日志管理>5.2.4 日志管理</a></li></ul></li></ul></li><li><a href=#6-总结>6 总结</a></li></ul></nav></div></div><div class=content id=content><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>注意<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p><a href=http://coding-geek.com/how-databases-work/ target=_blank rel="noopener noreffer">原文在这</a></p><p>由于博主英语水平有限，本篇译文以段落为单元，先英后中展示。</p><p>较之原文省略了一些博主认为可以缺少的图片。</p><p><strong>加粗</strong> 用来表示原文中强调的内容， <em>斜体</em> 用于表示博主的想法。</p></div></div></div><blockquote><p>When it comes to relational databases, I can’t help thinking that something is missing. They’re used everywhere. There are many different databases: from the small and useful SQLite to the powerful Teradata. But, there are only a few articles that explain how a database works. You can google by yourself “how does a relational database work” to see how few results there are. Moreover, those articles are short. Now, if you look for the last trendy technologies (Big Data, NoSQL or JavaScript), you’ll find more in-depth articles explaining how they work.</p></blockquote><p>当谈到关系型数据库的时候，我不禁会想少了点啥。
它们使用广泛。
这里有许多种不同的数据库：从小而实用的SQLite到强大的Teradata。
但是很少有文章介绍一个数据库是怎么工作的。
你可以自己谷歌搜索一下"how does a relational database work"看看有多少有信息的文章。
此外这些文章都很短。
与此同时，你去搜索现在时兴的一些技术（大数据，NoSQL或者JS），你能找到很多对原理解析很有深度的文章。</p><blockquote><p>Are relational databases too old and too boring to be explained outside of university courses, research papers and books?</p></blockquote><p>是否是因为关系型数据库太过老旧无聊，以至于无法在大学课程、论文以及书籍之外来介绍其原理吗？</p><blockquote><p>As a developer, I HATE using something I don’t understand. And, if databases have been used for 40 years, there must be a reason. Over the years, I’ve spent hundreds of hours to really understand these weird black boxes I use every day. Relational Databases are very interesting because they’re based on useful and reusable concepts. If understanding a database interests you but you’ve never had the time or the will to dig into this wide subject, you should like this article.</p></blockquote><p>作为一个开发者，我痛恨实用那些我不理解的技术。
并且数据库被使用了长达四十多年肯定是有原因的。
这些年来我花了数百小时来真正理解这些我每天都在使用的奇怪黑盒。
关系型数据库是非常有趣的，因为其构建基于一些非常有用并且可以复用的概念之上。
如果你对理解一个数据库有点兴趣但你又没有时间或者没有这个意愿来钻研这个广泛的主题，你会喜欢这篇文章的。</p><blockquote><p>Though the title of this article is explicit, the aim of this article is NOT to understand how to use a database. Therefore, you should already know how to write a simple join query and basic CRUD queries; otherwise you might not understand this article. This is the only thing you need to know, I’ll explain everything else.</p></blockquote><p>尽管标题写的很清楚，但还是要强调的是这篇文章的目的 <strong>不是</strong> 让你理解怎么来使用数据库。
因此，你需要有一些基础知识，例如会写简单的join查询、会基本的增删查改，否则你会看得云里雾里。
除此之外的一切内容都会涵盖在这篇文章中。</p><blockquote><p>I’ll start with some computer science stuff like time complexity. I know that some of you hate this concept but, without it, you can’t understand the cleverness inside a database. Since it’s a huge topic, I’ll focus on what I think is essential: the way a database handles an SQL query. I’ll only present the basic concepts behind a database so that at the end of the article you’ll have a good idea of what’s happening under the hood.</p></blockquote><p>我会从类似时间复杂度这样的计算机概念开始介绍。
我知道你们可能讨厌这类概念，但是如果不讲这些概念你们很难理解数据库内部的高明之处。
因为这是一个很大的话题，我会聚焦于介绍 <strong>数据库处理一条SQL的方法</strong> 这条主线。
我仅会介绍数据库内部的一些基本概念，这样你在读完本文后能对数据库内部究竟干了些啥有一个比较清晰的理解。</p><blockquote><p>Since it’s a long and technical article that involves many algorithms and data structures, take your time to read it. Some concepts are more difficult to understand; you can skip them and still get the overall idea.</p></blockquote><p>因为这是一篇涉及了很多算法和数据结构的技术文章，慢慢读吧。
其中的有些概念可能很难理解，你可以暂时地跳过这些部分，不会影响整体的理解。</p><blockquote><p>For the more knowledgeable of you, this article is more or less divided into 3 parts:</p><ul><li>An overview of low-level and high-level database components</li><li>An overview of the query optimization process</li><li>An overview of the transaction and buffer pool management</li></ul></blockquote><p>为了你们更容易理解，这篇文章可以大致分为三个部分：</p><ul><li>对数据库底层和顶层组件的概述</li><li>对查询优化过程的概述</li><li>对事务和缓存池管理的概述</li></ul><h1 id=1-回顾基础>1 回顾基础</h1><blockquote><p>A long time ago (in a galaxy far, far away….), developers had to know exactly the number of operations they were coding. They knew by heart their algorithms and data structures because they couldn’t afford to waste the CPU and memory of their slow computers.</p></blockquote><p>很久以前（在遥远的银河系），开发人员需要精确的知道自己写的代码需要进行的操作数。
他们对自己的算法和数据结构了然于心，因为他们无法忍受在其低速电脑上浪费CPU和内存。</p><blockquote><p>In this part, I’ll remind you about some of these concepts because they are essential to understand a database. I’ll also introduce the notion of database index.</p></blockquote><p>在这一部分我会带你重温一下这些概念，因为他们对理解数据库来说至关重要。
同时我会向你介绍 <strong>数据库索引</strong> 的概念。</p><h2 id=11-o1-vs-on2>1.1 $O(1)$ vs $O(n^2)$</h2><blockquote><p>Nowadays, many developers don’t care about time complexity … and they’re right!</p></blockquote><p>现在很多开发者不太关心时间复杂度，正确的！</p><blockquote><p>But when you deal with a large amount of data (I’m not talking about thousands) or if you’re fighting for milliseconds, it becomes critical to understand this concept. And guess what, databases have to deal with both situations! I won’t bore you a long time, just the time to get the idea. This will help us later to understand the concept of cost based optimization.</p></blockquote><p>但是当你处理一个量级很大的数据（这里说的不是千级别的）或需要考虑毫秒级别性能问题时，理解这个概念就变得至关重要了。
你猜怎么着，数据库两种情况都需要处理！
我不会在这部分花费你太多时间，仅仅有一个大体印象即可。
这对接下来理解 <strong>基于开销的性能优化</strong> 很关键。</p><h3 id=111-概念>1.1.1 概念</h3><blockquote><p>The time complexity is used to see how long an algorithm will take for a given amount of data. To describe this complexity, computer scientists use the mathematical big O notation. This notation is used with a function that describes how many operations an algorithm needs for a given amount of input data.</p></blockquote><p><strong>时间复杂度用来描述一个算法对于给定数量级的数据需要花费多久的时间来处理</strong>。
计算机科学家们用大O表示法来描述这种复杂度。
这种表示法通常与函数搭配使用，函数用来描述对于一个给定量级的输入数据这个算法需要进行多少次操作。</p><blockquote><p>For example, when I say “this algorithm is in O( some_function() )”, it means that for a certain amount of data the algorithm needs some_function(a_certain_amount_of_data) operations to do its job.</p></blockquote><p>举例来说，当我说这个算法是 <code>O(some_function())</code> 的时候，表示着对于一个给定的量级的数据，这个算法需要 <code>some_function(a_certain_amount_of_data)</code> 次操作才能执行完毕。</p><blockquote><p>What’s important is not the amount of data but the way the number of operations increases when the amount of data increases. The time complexity doesn’t give the exact number of operations but a good idea.</p></blockquote><p>这里关键点并不是数据的量级，而是 <strong>操作数随数据增长时的增长量</strong> 。
时间复杂度并没有给出具体的操作次数而是描述了一个大致量。</p><figure><a class=lightgallery href=/images/TimeComplexity.png title=/images/TimeComplexity.png data-thumbnail=/images/TimeComplexity.png data-sub-html="<h2>时间复杂度</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/TimeComplexity.png data-srcset="/images/TimeComplexity.png, /images/TimeComplexity.png 1.5x, /images/TimeComplexity.png 2x" data-sizes=auto alt=/images/TimeComplexity.png height=1500 width=1500></a><figcaption class=image-caption>时间复杂度</figcaption></figure><blockquote><p>In this figure, you can see the evolution of different types of complexities. I used a logarithmic scale to plot it. In other words, the number of data is quickly increasing from 1 to 1 billion. We can see that:</p><ul><li>The O(1) or constant complexity stays constant (otherwise it wouldn’t be called constant complexity).</li><li>The O(log(n)) stays low even with billions of data.</li><li>The worst complexity is the O(n2) where the number of operations quickly explodes.</li><li>The two other complexities are quickly increasing.</li></ul></blockquote><p>在上面的图片中可以看到不同类型复杂度的演化。使用的是对数刻度。
换言之，数据的量级从1到10亿快速增长。
我们可以看到：</p><ul><li><div id=id-1><strong>$O(1)$</strong> 或者说常量复杂度随着数据量增长保持常量（不然它也不会叫常量复杂度）</div></li><li><div id=id-2><strong>$O(log(n))$</strong> 即使在十亿的数据量下操作增长也很慢</div></li><li><div id=id-3>最差的复杂度是 <strong>$O(n^2)$</strong> ，操作的数量爆炸增长</div></li><li>其他两种复杂度增长迅速</li></ul><h3 id=112-例子>1.1.2 例子</h3><blockquote><p>With a low amount of data, the difference between O(1) and O(n2) is negligible. For example, let’s say you have an algorithm that needs to process 2000 elements.</p><ul><li>An $O(1)$ algorithm will cost you 1 operation</li><li>An $O(log(n))$ algorithm will cost you 7 operations</li><li>An $O(n)$ algorithm will cost you 2 000 operations</li><li>An $O(n*log(n))$ algorithm will cost you 14 000 operations</li><li>An $O(n^2)$ algorithm will cost you 4 000 000 operations</li></ul></blockquote><p>在数据很少的时候，$O(1)$和$O(n^2)$的差距可以忽略。举个例子，当一个算法需要处理2000个元素的时候。</p><ul><li>$O(1)$的算法需要进行 1 次操作</li><li>$O(log(n))$的算法需要进行 7 次操作</li><li>$O(n)$的算法需要进行 2 000 次操作</li><li>$O(n*log(n))$的算法需要进行 14 000 次操作</li><li>$O(n^2)$的算法需要进行 4 000 000 次操作</li></ul><blockquote><p>The difference between $O(1)$ and $O(n^2)$ seems a lot (4 million) but you’ll lose at max 2 ms, just the time to blink your eyes. Indeed, current processors can handle hundreds of millions of operations per second. This is why performance and optimization are not an issue in many IT projects.</p></blockquote><p>这里的$O(1)$和$O(n^2)$看起来差距很大(4 000 000 : 1)但是性能损耗最大2ms，一眨眼的功夫。
现在的处理器(本文写于2015年)每秒可以进行数十亿次操作。
这就是为什么在很多IT项目中性能和优化并不是主要问题。</p><blockquote><p>As I said, it’s still important to know this concept when facing a huge number of data. If this time the algorithm needs to process 1 000 000 elements (which is not that big for a database):</p><ul><li>An $O(1)$ algorithm will cost you 1 operation</li><li>An $O(log(n))$ algorithm will cost you 14 operations</li><li>An $O(n)$ algorithm will cost you 1 000 000 operations</li><li>An $O(n*log(n))$ algorithm will cost you 14 000 000 operations</li><li>An $O(n^2)$ algorithm will cost you 1 000 000 000 000 operations</li></ul></blockquote><p>如我所说，当面对一个量级相当大的数据时，时间复杂度的概念就相当重要了。
如果这次这个算法需要处理一百万个元素（对数据库来说这个数量级都还不算大）：</p><ul><li>$O(1)$的算法需要进行 1 次操作</li><li>$O(log(n))$的算法需要进行 14 次操作</li><li>$O(n)$的算法需要进行 1 000 000 次操作</li><li>$O(n*log(n))$的算法需要进行 14 000 000次操作</li><li>$O(n^2)$的算法需要进行 1 000 000 000 000 次操作</li></ul><blockquote><p>I didn’t do the math but I’d say with the $O(n2)$ algorithm you have the time to take a coffee (even a second one!). If you put another 0 on the amount of data, you’ll have the time to take a long nap.</p></blockquote><p>我没有具体算过，但是这一次$O(n^2)$的算法都够你喝杯咖啡了（甚至喝两杯！）如果数量级再加个0，甚至能睡个午觉。</p><h3 id=113-更深入一点>1.1.3 更深入一点</h3><blockquote><p>To give you an idea:</p><ul><li>A search in a good hash table gives an element in O(1)</li><li>A search in a well-balanced tree gives a result in O(log(n))</li><li>A search in an array gives a result in O(n)</li><li>The best sorting algorithms have an O(n*log(n)) complexity.</li><li>A bad sorting algorithm has an O(n2) complexity</li></ul></blockquote><p>为了让你对时间复杂度的有一个大致的印象：</p><ul><li>在一个比较好的哈希表中执行查找的时间复杂度是$O(1)$</li><li>在一个平衡地很好的树中执行查找的时间复杂度是$O(log(n))$</li><li>在数组中执行查找的时间复杂度是$O(n)$</li><li>最好的排序算法时间复杂度是$O(n*log(s))$</li><li>捞的排序算法时间复杂度是$O(n^2)$</li></ul><blockquote><p>Note: In the next parts, we’ll see these algorithms and data structures.</p></blockquote><p>注意：下一小节就会看一下这些算法喝数据结构。</p><blockquote><p>There are multiple types of time complexity:</p><ul><li>the average case scenario</li><li>the best case scenario</li><li>and the worst case scenario</li></ul></blockquote><p>关于时间复杂度有几种类型：</p><ul><li>平均的时间复杂度</li><li>最好的情况对应的复杂度</li><li>最坏的情况对应的复杂度</li></ul><blockquote><p>The time complexity is often the worst case scenario.</p></blockquote><p>一个算法的时间复杂度通常指的是最坏情况的时间复杂度。</p><blockquote><p>I only talked about time complexity but complexity also works for:</p><ul><li>the memory consumption of an algorithm</li><li>the disk I/O consumption of an algorithm</li></ul></blockquote><p>这里我只谈到了时间复杂度，复杂度同样适合于描述：</p><ul><li>一个算法的内存开销</li><li>一个算法的磁盘IO开销</li></ul><blockquote><p>Of course there are worse complexities than $n^2$, like:</p><ul><li>$n^4$: that sucks! Some of the algorithms I’ll mention have this complexity.</li><li>$3^n$: that sucks even more! One of the algorithms we’re going to see in the middle of this article has this complexity (and it’s really used in many databases).</li><li>factorial n : you’ll never get your results, even with a low amount of data.</li><li>$n^n$: if you end-up with this complexity, you should ask yourself if IT is really your field…</li></ul></blockquote><p>当然还有比$n^2$更捞的时间复杂度，如下：</p><ul><li>$n^4$：捞得不谈，有的算法是这个时间复杂度。</li><li>$3^n$：捞得淌口水，文章中部有一个算法是这个复杂度。</li><li>$n!$：时间的尽头。</li><li>$n^n$：如果你写出这样的时间复杂度的算法，只能说一眼顶真，鉴定为不适合写代码。</li></ul><p><em>读到这里的朋友不妨自己写一个$n^n$的算法试试，博主还真想不到怎么写一个</em></p><blockquote><p>Note: I didn’t give you the real definition of the big O notation but just the idea. You can read this article on Wikipedia for the real (asymptotic) definition.</p></blockquote><p>注意：这里我并没有给出关于大O表示法的严谨定义。你可以通过<a href=https://en.wikipedia.org/wiki/Big_O_notation target=_blank rel="noopener noreffer">wikipedia</a>看看更准确的定义。</p><h2 id=12-归并排序>1.2 归并排序</h2><h3 id=121-合并>1.2.1 合并</h3><h3 id=122-分治过程>1.2.2 分治过程</h3><h3 id=123-排序过程>1.2.3 排序过程</h3><h3 id=124-归并排序的强大之处>1.2.4 归并排序的强大之处</h3><h2 id=13-数组树和哈希表>1.3 数组，树和哈希表</h2><h3 id=131-数组>1.3.1 数组</h3><h3 id=132-树和数据库索引>1.3.2 树和数据库索引</h3><h3 id=133-哈希表>1.3.3 哈希表</h3><h1 id=2-全局概述>2 全局概述</h1><h1 id=3-客户端管理>3 客户端管理</h1><h1 id=4-查询管理>4 查询管理</h1><h2 id=41-查询解析>4.1 查询解析</h2><h2 id=42-查询重写>4.2 查询重写</h2><h2 id=43-统计信息>4.3 统计信息</h2><h2 id=44-查询优化器>4.4 查询优化器</h2><h3 id=441-索引>4.4.1 索引</h3><h3 id=442-访问路径>4.4.2 访问路径</h3><h3 id=443-联结操作>4.4.3 联结操作</h3><h3 id=444-简化的案例>4.4.4 简化的案例</h3><h3 id=445-动态规划贪心算法和启发式>4.4.5 动态规划、贪心算法和启发式</h3><h3 id=446-真正的优化器unimportant-part>4.4.6 真正的优化器(unimportant part)</h3><h3 id=447-查询计划缓存>4.4.7 查询计划缓存</h3><h2 id=45-查询执行>4.5 查询执行</h2><h1 id=5-数据管理>5 数据管理</h1><h2 id=51-缓存管理>5.1 缓存管理</h2><h3 id=511-预取>5.1.1 预取</h3><h3 id=512-缓存替换策略>5.1.2 缓存替换策略</h3><h3 id=513-写缓存>5.1.3 写缓存</h3><h2 id=52-事务管理>5.2 事务管理</h2><h3 id=521-酸了>5.2.1 酸了</h3><h3 id=522-并发控制>5.2.2 并发控制</h3><h3 id=523-锁管理>5.2.3 锁管理</h3><h3 id=524-日志管理>5.2.4 日志管理</h3><h1 id=6-总结>6 总结</h1></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-05-11</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/db/>db</a>,&nbsp;<a href=/tags/rdbms/>rdbms</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/cmu15445-db-storage/ class=prev rel=prev title=[note]数据库存储><i class="fas fa-angle-left fa-fw"></i>[note]数据库存储</a></div></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk></a>Gitalk</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.98.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>zh</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/gitalk/gitalk.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/css/befdf6.min.css><script type=text/javascript src=/lib/gitalk/gitalk.min.js></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{gitalk:{admin:["rustzzh"],clientID:"da0c5fc5ea73e5fd68b1",clientSecret:"b109d474223d93fb730ca7e01f2b4d0d63fcc60d",id:"2022-05-09T17:35:56+08:00",owner:"rustzzh",repo:"rustzzh.github.io",title:"[tran]关系型数据库原理"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>