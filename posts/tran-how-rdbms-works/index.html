<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>[tran]关系型数据库原理 - zh's blog</title><meta name=Description content="(WIP)通过翻译这篇文章达到精读一遍的效果"><meta property="og:title" content="[tran]关系型数据库原理"><meta property="og:description" content="(WIP)通过翻译这篇文章达到精读一遍的效果"><meta property="og:type" content="article"><meta property="og:url" content="https://rustzzh.github.io/posts/tran-how-rdbms-works/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-09T17:35:56+08:00"><meta property="article:modified_time" content="2022-05-12T11:47:29+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[tran]关系型数据库原理"><meta name=twitter:description content="(WIP)通过翻译这篇文章达到精读一遍的效果"><meta name=application-name content="zh's blog"><meta name=apple-mobile-web-app-title content="zh's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://rustzzh.github.io/posts/tran-how-rdbms-works/><link rel=prev href=https://rustzzh.github.io/posts/cmu15445-db-storage/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"[tran]关系型数据库原理","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/rustzzh.github.io\/posts\/tran-how-rdbms-works\/"},"genre":"posts","keywords":"db, rdbms","wordcount":6170,"url":"https:\/\/rustzzh.github.io\/posts\/tran-how-rdbms-works\/","datePublished":"2022-05-09T17:35:56+08:00","dateModified":"2022-05-12T11:47:29+00:00","publisher":{"@type":"Organization","name":"zh"},"author":{"@type":"Person","name":"zh"},"description":"(WIP)通过翻译这篇文章达到精读一遍的效果"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":''==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:''==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="zh's blog">zh's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/friend/>友链 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="zh's blog">zh's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/friend/ title>友链</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">[tran]关系型数据库原理</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>zh</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-05-09>2022-05-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 6170 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 13 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-回顾基础>1 回顾基础</a><ul><li><a href=#11-o1-vs-on2>1.1 $O(1)$ vs $O(n^2)$</a><ul><li><a href=#111-概念>1.1.1 概念</a></li><li><a href=#112-例子>1.1.2 例子</a></li><li><a href=#113-更深入一点>1.1.3 更深入一点</a></li></ul></li><li><a href=#12-归并排序>1.2 归并排序</a><ul><li><a href=#121-合并>1.2.1 合并</a></li><li><a href=#122-分治过程>1.2.2 分治过程</a></li><li><a href=#123-排序过程>1.2.3 排序过程</a></li><li><a href=#124-归并排序的强大之处>1.2.4 归并排序的强大之处</a></li></ul></li><li><a href=#13-数组树和哈希表>1.3 数组，树和哈希表</a><ul><li><a href=#131-数组>1.3.1 数组</a></li><li><a href=#132-树和数据库索引>1.3.2 树和数据库索引</a></li><li><a href=#133-哈希表>1.3.3 哈希表</a></li></ul></li></ul></li><li><a href=#2-全局概述>2 全局概述</a></li><li><a href=#3-客户端管理>3 客户端管理</a></li><li><a href=#4-查询管理>4 查询管理</a><ul><li><a href=#41-查询解析>4.1 查询解析</a></li><li><a href=#42-查询重写>4.2 查询重写</a></li><li><a href=#43-统计信息>4.3 统计信息</a></li><li><a href=#44-查询优化器>4.4 查询优化器</a><ul><li><a href=#441-索引>4.4.1 索引</a></li><li><a href=#442-访问路径>4.4.2 访问路径</a></li><li><a href=#443-联结操作>4.4.3 联结操作</a></li><li><a href=#444-简化的案例>4.4.4 简化的案例</a></li><li><a href=#445-动态规划贪心算法和启发式>4.4.5 动态规划、贪心算法和启发式</a></li><li><a href=#446-真正的优化器unimportant-part>4.4.6 真正的优化器(unimportant part)</a></li><li><a href=#447-查询计划缓存>4.4.7 查询计划缓存</a></li></ul></li><li><a href=#45-查询执行>4.5 查询执行</a></li></ul></li><li><a href=#5-数据管理>5 数据管理</a><ul><li><a href=#51-缓存管理>5.1 缓存管理</a><ul><li><a href=#511-预取>5.1.1 预取</a></li><li><a href=#512-缓存替换策略>5.1.2 缓存替换策略</a></li><li><a href=#513-写缓存>5.1.3 写缓存</a></li></ul></li><li><a href=#52-事务管理>5.2 事务管理</a><ul><li><a href=#521-酸了>5.2.1 酸了</a></li><li><a href=#522-并发控制>5.2.2 并发控制</a></li><li><a href=#523-锁管理>5.2.3 锁管理</a></li><li><a href=#524-日志管理>5.2.4 日志管理</a></li></ul></li></ul></li><li><a href=#6-总结>6 总结</a></li></ul></nav></div></div><div class=content id=content><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>注意<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p><a href=http://coding-geek.com/how-databases-work/ target=_blank rel="noopener noreffer">原文在这</a></p><p>由于博主英语水平有限，本篇译文以段落为单元，先英后中展示。</p><p>较之原文省略了一些博主认为可以缺少的图片。</p><p><strong>加粗</strong> 用来表示原文中强调的内容， <em>斜体</em> 用于表示博主的想法。</p></div></div></div><blockquote><p>When it comes to relational databases, I can’t help thinking that something is missing. They’re used everywhere. There are many different databases: from the small and useful SQLite to the powerful Teradata. But, there are only a few articles that explain how a database works. You can google by yourself “how does a relational database work” to see how few results there are. Moreover, those articles are short. Now, if you look for the last trendy technologies (Big Data, NoSQL or JavaScript), you’ll find more in-depth articles explaining how they work.</p></blockquote><p>当谈到关系型数据库的时候，我不禁会想少了点啥。
它们使用广泛。
这里有许多种不同的数据库：从小而实用的SQLite到强大的Teradata。
但是很少有文章介绍一个数据库是怎么工作的。
你可以自己谷歌搜索一下"how does a relational database work"看看有多少有信息的文章。
此外这些文章都很短。
与此同时，你去搜索现在时兴的一些技术(大数据，NoSQL或者JS)，你能找到很多对原理解析很有深度的文章。</p><blockquote><p>Are relational databases too old and too boring to be explained outside of university courses, research papers and books?</p></blockquote><p>是否是因为关系型数据库太过老旧无聊，以至于无法在大学课程、论文以及书籍之外来介绍其原理吗？</p><blockquote><p>As a developer, I HATE using something I don’t understand. And, if databases have been used for 40 years, there must be a reason. Over the years, I’ve spent hundreds of hours to really understand these weird black boxes I use every day. Relational Databases are very interesting because they’re based on useful and reusable concepts. If understanding a database interests you but you’ve never had the time or the will to dig into this wide subject, you should like this article.</p></blockquote><p>作为一个开发者，我痛恨实用那些我不理解的技术。
并且数据库被使用了长达四十多年肯定是有原因的。
这些年来我花了数百小时来真正理解这些我每天都在使用的奇怪黑盒。
关系型数据库是非常有趣的，因为其构建基于一些非常有用并且可以复用的概念之上。
如果你对理解一个数据库有点兴趣但你又没有时间或者没有这个意愿来钻研这个广泛的主题，你会喜欢这篇文章的。</p><blockquote><p>Though the title of this article is explicit, the aim of this article is NOT to understand how to use a database. Therefore, you should already know how to write a simple join query and basic CRUD queries; otherwise you might not understand this article. This is the only thing you need to know, I’ll explain everything else.</p></blockquote><p>尽管标题写的很清楚，但还是要强调的是这篇文章的目的 <strong>不是</strong> 让你理解怎么来使用数据库。
因此，你需要有一些基础知识，例如会写简单的join查询、会基本的增删查改，否则你会看得云里雾里。
除此之外的一切内容都会涵盖在这篇文章中。</p><blockquote><p>I’ll start with some computer science stuff like time complexity. I know that some of you hate this concept but, without it, you can’t understand the cleverness inside a database. Since it’s a huge topic, I’ll focus on what I think is essential: the way a database handles an SQL query. I’ll only present the basic concepts behind a database so that at the end of the article you’ll have a good idea of what’s happening under the hood.</p></blockquote><p>我会从类似时间复杂度这样的计算机概念开始介绍。
我知道你们可能讨厌这类概念，但是如果不讲这些概念你们很难理解数据库内部的高明之处。
因为这是一个很大的话题，我会聚焦于介绍 <strong>数据库处理一条SQL的方法</strong> 这条主线。
我仅会介绍数据库内部的一些基本概念，这样你在读完本文后能对数据库内部究竟干了些啥有一个比较清晰的理解。</p><blockquote><p>Since it’s a long and technical article that involves many algorithms and data structures, take your time to read it. Some concepts are more difficult to understand; you can skip them and still get the overall idea.</p></blockquote><p>因为这是一篇涉及了很多算法和数据结构的技术文章，慢慢读吧。
其中的有些概念可能很难理解，你可以暂时地跳过这些部分，不会影响整体的理解。</p><blockquote><p>For the more knowledgeable of you, this article is more or less divided into 3 parts:</p><ul><li>An overview of low-level and high-level database components</li><li>An overview of the query optimization process</li><li>An overview of the transaction and buffer pool management</li></ul></blockquote><p>为了你们更容易理解，这篇文章可以大致分为三个部分：</p><ul><li>对数据库底层和顶层组件的概述</li><li>对查询优化过程的概述</li><li>对事务和缓存池管理的概述</li></ul><h1 id=1-回顾基础>1 回顾基础</h1><blockquote><p>A long time ago (in a galaxy far, far away….), developers had to know exactly the number of operations they were coding. They knew by heart their algorithms and data structures because they couldn’t afford to waste the CPU and memory of their slow computers.</p></blockquote><p>很久以前(在遥远的银河系)，开发人员需要精确的知道自己写的代码需要进行的操作数。
他们对自己的算法和数据结构了然于心，因为他们无法忍受在其低速电脑上浪费CPU和内存。</p><blockquote><p>In this part, I’ll remind you about some of these concepts because they are essential to understand a database. I’ll also introduce the notion of database index.</p></blockquote><p>在这一部分我会带你重温一下这些概念，因为他们对理解数据库来说至关重要。
同时我会向你介绍 <strong>数据库索引</strong> 的概念。</p><h2 id=11-o1-vs-on2>1.1 $O(1)$ vs $O(n^2)$</h2><blockquote><p>Nowadays, many developers don’t care about time complexity … and they’re right!</p></blockquote><p>现在很多开发者不太关心时间复杂度，正确的！</p><blockquote><p>But when you deal with a large amount of data (I’m not talking about thousands) or if you’re fighting for milliseconds, it becomes critical to understand this concept. And guess what, databases have to deal with both situations! I won’t bore you a long time, just the time to get the idea. This will help us later to understand the concept of cost based optimization.</p></blockquote><p>但是当你处理一个量级很大的数据(这里说的不是千级别的)或需要考虑毫秒级别性能问题时，理解这个概念就变得至关重要了。
你猜怎么着，数据库两种情况都需要处理！
我不会在这部分花费你太多时间，仅仅有一个大体印象即可。
这对接下来理解 <strong>基于开销的性能优化</strong> 很关键。</p><h3 id=111-概念>1.1.1 概念</h3><blockquote><p>The time complexity is used to see how long an algorithm will take for a given amount of data. To describe this complexity, computer scientists use the mathematical big O notation. This notation is used with a function that describes how many operations an algorithm needs for a given amount of input data.</p></blockquote><p><strong>时间复杂度用来描述一个算法对于给定数量级的数据需要花费多久的时间来处理</strong>。
计算机科学家们用大O表示法来描述这种复杂度。
这种表示法通常与函数搭配使用，函数用来描述对于一个给定量级的输入数据这个算法需要进行多少次操作。</p><blockquote><p>For example, when I say “this algorithm is in O( some_function() )”, it means that for a certain amount of data the algorithm needs some_function(a_certain_amount_of_data) operations to do its job.</p></blockquote><p>举例来说，当我说这个算法是 <code>O(some_function())</code> 的时候，表示着对于一个给定的量级的数据，这个算法需要 <code>some_function(a_certain_amount_of_data)</code> 次操作才能执行完毕。</p><blockquote><p>What’s important is not the amount of data but the way the number of operations increases when the amount of data increases. The time complexity doesn’t give the exact number of operations but a good idea.</p></blockquote><p>这里关键点并不是数据的量级，而是 <strong>操作数随数据增长时的增长量</strong> 。
时间复杂度并没有给出具体的操作次数而是描述了一个大致量。</p><figure><a class=lightgallery href=/images/TimeComplexity.png title=/images/TimeComplexity.png data-thumbnail=/images/TimeComplexity.png data-sub-html="<h2>时间复杂度</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/TimeComplexity.png data-srcset="/images/TimeComplexity.png, /images/TimeComplexity.png 1.5x, /images/TimeComplexity.png 2x" data-sizes=auto alt=/images/TimeComplexity.png height=1500 width=1500></a><figcaption class=image-caption>时间复杂度</figcaption></figure><blockquote><p>In this figure, you can see the evolution of different types of complexities. I used a logarithmic scale to plot it. In other words, the number of data is quickly increasing from 1 to 1 billion. We can see that:</p><ul><li>The O(1) or constant complexity stays constant (otherwise it wouldn’t be called constant complexity).</li><li>The O(log(n)) stays low even with billions of data.</li><li>The worst complexity is the O(n2) where the number of operations quickly explodes.</li><li>The two other complexities are quickly increasing.</li></ul></blockquote><p>在上面的图片中可以看到不同类型复杂度的演化。使用的是对数刻度。
换言之，数据的量级从1到10亿快速增长。
我们可以看到：</p><ul><li><div id=id-1><strong>$O(1)$</strong> 或者说常量复杂度随着数据量增长保持常量(不然它也不会叫常量复杂度)</div></li><li><div id=id-2><strong>$O(log(n))$</strong> 即使在十亿的数据量下操作增长也很慢</div></li><li><div id=id-3>最差的复杂度是 <strong>$O(n^2)$</strong> ，操作的数量爆炸增长</div></li><li>其他两种复杂度增长迅速</li></ul><h3 id=112-例子>1.1.2 例子</h3><blockquote><p>With a low amount of data, the difference between O(1) and O(n2) is negligible. For example, let’s say you have an algorithm that needs to process 2000 elements.</p><ul><li>An $O(1)$ algorithm will cost you 1 operation</li><li>An $O(log(n))$ algorithm will cost you 7 operations</li><li>An $O(n)$ algorithm will cost you 2 000 operations</li><li>An $O(n*log(n))$ algorithm will cost you 14 000 operations</li><li>An $O(n^2)$ algorithm will cost you 4 000 000 operations</li></ul></blockquote><p>在数据很少的时候，$O(1)$和$O(n^2)$的差距可以忽略。举个例子，当一个算法需要处理2000个元素的时候。</p><ul><li>$O(1)$的算法需要进行 1 次操作</li><li>$O(log(n))$的算法需要进行 7 次操作</li><li>$O(n)$的算法需要进行 2 000 次操作</li><li>$O(n*log(n))$的算法需要进行 14 000 次操作</li><li>$O(n^2)$的算法需要进行 4 000 000 次操作</li></ul><blockquote><p>The difference between $O(1)$ and $O(n^2)$ seems a lot (4 million) but you’ll lose at max 2 ms, just the time to blink your eyes. Indeed, current processors can handle hundreds of millions of operations per second. This is why performance and optimization are not an issue in many IT projects.</p></blockquote><p>这里的$O(1)$和$O(n^2)$看起来差距很大(4 000 000 : 1)但是性能损耗最大2ms，一眨眼的功夫。
现在的处理器(本文写于2015年)每秒可以进行数十亿次操作。
这就是为什么在很多IT项目中性能和优化并不是主要问题。</p><blockquote><p>As I said, it’s still important to know this concept when facing a huge number of data. If this time the algorithm needs to process 1 000 000 elements (which is not that big for a database):</p><ul><li>An $O(1)$ algorithm will cost you 1 operation</li><li>An $O(log(n))$ algorithm will cost you 14 operations</li><li>An $O(n)$ algorithm will cost you 1 000 000 operations</li><li>An $O(n*log(n))$ algorithm will cost you 14 000 000 operations</li><li>An $O(n^2)$ algorithm will cost you 1 000 000 000 000 operations</li></ul></blockquote><p>如我所说，当面对一个量级相当大的数据时，时间复杂度的概念就相当重要了。
如果这次这个算法需要处理一百万个元素(对数据库来说这个数量级都还不算大)：</p><ul><li>$O(1)$的算法需要进行 1 次操作</li><li>$O(log(n))$的算法需要进行 14 次操作</li><li>$O(n)$的算法需要进行 1 000 000 次操作</li><li>$O(n*log(n))$的算法需要进行 14 000 000次操作</li><li>$O(n^2)$的算法需要进行 1 000 000 000 000 次操作</li></ul><blockquote><p>I didn’t do the math but I’d say with the $O(n2)$ algorithm you have the time to take a coffee (even a second one!). If you put another 0 on the amount of data, you’ll have the time to take a long nap.</p></blockquote><p>我没有具体算过，但是这一次$O(n^2)$的算法都够你喝杯咖啡了(甚至喝两杯！)如果数量级再加个0，甚至能睡个午觉。</p><h3 id=113-更深入一点>1.1.3 更深入一点</h3><blockquote><p>To give you an idea:</p><ul><li>A search in a good hash table gives an element in O(1)</li><li>A search in a well-balanced tree gives a result in O(log(n))</li><li>A search in an array gives a result in O(n)</li><li>The best sorting algorithms have an O(n*log(n)) complexity.</li><li>A bad sorting algorithm has an O(n2) complexity</li></ul></blockquote><p>为了让你对时间复杂度的有一个大致的印象：</p><ul><li>在一个比较好的哈希表中执行查找的时间复杂度是$O(1)$</li><li>在一个平衡地很好的树中执行查找的时间复杂度是$O(log(n))$</li><li>在数组中执行查找的时间复杂度是$O(n)$</li><li>最好的排序算法时间复杂度是$O(n*log(s))$</li><li>捞的排序算法时间复杂度是$O(n^2)$</li></ul><blockquote><p>Note: In the next parts, we’ll see these algorithms and data structures.</p></blockquote><p>注：下一小节就会看一下这些算法喝数据结构。</p><blockquote><p>There are multiple types of time complexity:</p><ul><li>the average case scenario</li><li>the best case scenario</li><li>and the worst case scenario</li></ul></blockquote><p>关于时间复杂度有几种类型：</p><ul><li>平均的时间复杂度</li><li>最好的情况对应的复杂度</li><li>最坏的情况对应的复杂度</li></ul><blockquote><p>The time complexity is often the worst case scenario.</p></blockquote><p>一个算法的时间复杂度通常指的是最坏情况的时间复杂度。</p><blockquote><p>I only talked about time complexity but complexity also works for:</p><ul><li>the memory consumption of an algorithm</li><li>the disk I/O consumption of an algorithm</li></ul></blockquote><p>这里我只谈到了时间复杂度，复杂度同样适合于描述：</p><ul><li>一个算法的内存开销</li><li>一个算法的磁盘IO开销</li></ul><blockquote><p>Of course there are worse complexities than $n^2$, like:</p><ul><li>$n^4$: that sucks! Some of the algorithms I’ll mention have this complexity.</li><li>$3^n$: that sucks even more! One of the algorithms we’re going to see in the middle of this article has this complexity (and it’s really used in many databases).</li><li>factorial n : you’ll never get your results, even with a low amount of data.</li><li>$n^n$: if you end-up with this complexity, you should ask yourself if IT is really your field…</li></ul></blockquote><p>当然还有比$n^2$更捞的时间复杂度，如下：</p><ul><li>$n^4$：捞得不谈，有的算法是这个时间复杂度。</li><li>$3^n$：捞得淌口水，文章中部有一个算法是这个复杂度。</li><li>$n!$：时间的尽头。</li><li>$n^n$：如果你写出这样的时间复杂度的算法，只能说一眼顶真，鉴定为不适合写代码。</li></ul><p><em>读到这里的朋友不妨自己写一个$n^n$的算法试试</em></p><blockquote><p>Note: I didn’t give you the real definition of the big O notation but just the idea. You can read this article on Wikipedia for the real (asymptotic) definition.</p></blockquote><p>注：这里我并没有给出关于大O表示法的严谨定义。你可以通过<a href=https://en.wikipedia.org/wiki/Big_O_notation target=_blank rel="noopener noreffer">wikipedia</a>看看更准确的定义。</p><h2 id=12-归并排序>1.2 归并排序</h2><blockquote><p>What do you do when you need to sort a collection? What? You call the sort() function … ok, good answer… But for a database you have to understand how this sort() function works.</p></blockquote><p>当你需要一个有序的元素集的时候需要干些啥呢？啥？你调用<code>sort()</code>&mldr;彳亍，好回答&mldr;但是对于数据库来说需要理解<code>sort()</code>是怎么运行的。</p><blockquote><p>There are several good sorting algorithms so I’ll focus on the most important one: the merge sort. You might not understand right now why sorting data is useful but you should after the part on query optimization. Moreover, understanding the merge sort will help us later to understand a common database join operation called the merge join.</p></blockquote><p>有很多不错的排序算法，这里聚焦于介绍 <strong>归并排序</strong> 。
可能现在你不知道为什么排序算法为什么重要，但看完查询优化那一节之后你应该就理解了。
除此之外，理解归并排序有助于我们之后来理解数据库中的一种常见操作：<strong>合并联结</strong>。</p><h3 id=121-合并>1.2.1 合并</h3><blockquote><p>Like many useful algorithms, the merge sort is based on a trick: merging 2 sorted arrays of size N/2 into a N-element sorted array only costs N operations. This operation is called a merge.</p></blockquote><p>像很多使用的算法一样，归并排序是基于这样一个点：将两个长度为 N/2 的有序数据合并成一个长度为 N 的有序数组只需要 N 次操作。
这个操作叫做 <strong>合并</strong>。</p><blockquote><p>Let’s see what this means with a simple example:</p></blockquote><p>看个例子：</p><figure><a class=lightgallery href=/images/merge_sort_3.png title=/images/merge_sort_3.png data-thumbnail=/images/merge_sort_3.png data-sub-html="<h2>归并</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/merge_sort_3.png data-srcset="/images/merge_sort_3.png, /images/merge_sort_3.png 1.5x, /images/merge_sort_3.png 2x" data-sizes=auto alt=/images/merge_sort_3.png height=500 width=500></a><figcaption class=image-caption>归并</figcaption></figure><blockquote><p>You can see on this figure that to construct the final sorted array of 8 elements, you only need to iterate one time in the 2 4-element arrays. Since both 4-element arrays are already sorted:</p><ol><li>you compare both current elements in the 2 arrays (current=first for the first time)</li><li>then take the lowest one to put it in the 8-element array</li><li>and go to the next element in the array you took the lowest element
and repeat 1,2,3 until you reach the last element of one of the arrays.</li></ol><p>Then you take the rest of the elements of the other array to put them in the 8-element array.</p></blockquote><p>从图片中能看到想要得到一个有序的 8 个元素的数组，需要遍历 2 个有序的 4 元素数组，因为这 2 个数组都是有序的：</p><ol><li>两个数组都从头遍历起，每次遍历比较当前二者的大小</li><li>将更小的那个数据塞入到 8 元素数组中</li><li>将第 2 步取数据的数组的遍历指针往后移一位，重复 1,2,3 步直到遍历完某一个数组</li></ol><p>将剩余的元素依次塞入这个 8 元素的数组。</p><blockquote><p>This works because both 4-element arrays are sorted and therefore you don’t need to “go back” in these arrays.</p></blockquote><p>这样行得通的原因是 2 个 4 元素的数组都是有序的，所以无需在这些数组中“回溯”。</p><blockquote><p>Now that we’ve understood this trick, here is my pseudocode of the merge sort.</p></blockquote><p>现在我们已经理解了这个技巧，下面是归并排序的伪代码</p><pre tabindex=0><code>array mergeSort(array a)
   if(length(a)==1)
      return a[0];
   end if
 
   //recursive calls
   [left_array right_array] := split_into_2_equally_sized_arrays(a);
   array new_left_array := mergeSort(left_array);
   array new_right_array := mergeSort(right_array);
 
   //merging the 2 small ordered arrays into a big one
   array result := merge(new_left_array,new_right_array);
   return result;
</code></pre><blockquote><p>The merge sort breaks the problem into smaller problems then finds the results of the smaller problems to get the result of the initial problem (note: this kind of algorithms is called divide and conquer). If you don’t understand this algorithm, don’t worry; I didn’t understand it the first time I saw it. If it can help you, I see this algorithm as a two-phase algorithm:</p><ul><li>The division phase where the array is divided into smaller arrays</li><li>The sorting phase where the small arrays are put together (using the merge) to form a bigger array.</li></ul></blockquote><p>归并排序把问题拆成很多子问题，然后通过解决子问题然后获得最初的大问题的答案(注：这种类型的算法又称为分治算法)。
如果不懂没关系；我第一次看的时候也没看懂。
或许这种解释可以帮助你理解，将其拆分成两个阶段理解：</p><ol><li>拆分阶段：数组被拆分成更小的数组</li><li>排序阶段：小数组被合并成一个大数组</li></ol><h3 id=122-分治过程>1.2.2 分治过程</h3><figure><a class=lightgallery href=/images/merge_sort_1.png title=/images/merge_sort_1.png data-thumbnail=/images/merge_sort_1.png data-sub-html="<h2>拆分</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/merge_sort_1.png data-srcset="/images/merge_sort_1.png, /images/merge_sort_1.png 1.5x, /images/merge_sort_1.png 2x" data-sizes=auto alt=/images/merge_sort_1.png height=500 width=500></a><figcaption class=image-caption>拆分</figcaption></figure><blockquote><p>During the division phase, the array is divided into unitary arrays using 3 steps. The formal number of steps is log(N) (since N=8, log(N) = 3).</p></blockquote><p>在拆分阶段，数组在 3 步内被拆分成单元素的数组。拆分的次数是$log(N)$。</p><blockquote><p>How do I know that?
<del>I’m a genius!</del> In one word: mathematics. The idea is that each step divides the size of the initial array by 2. The number of steps is the number of times you can divide the initial array by two. This is the exact definition of logarithm (in base 2).</p></blockquote><p>我怎么知道的？</p><p>~~我又不是天才！~~简而言之：数学。因为每一步都是将数组拆分成原始数组的 1/2 。因此总步数就是最初的数组能被 2 除以的次数。正好是以2为底的对数的定义。</p><h3 id=123-排序过程>1.2.3 排序过程</h3><figure><a class=lightgallery href=/images/merge_sort_2.png title=/images/merge_sort_2.png data-thumbnail=/images/merge_sort_2.png data-sub-html="<h2>排序</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/images/merge_sort_2.png data-srcset="/images/merge_sort_2.png, /images/merge_sort_2.png 1.5x, /images/merge_sort_2.png 2x" data-sizes=auto alt=/images/merge_sort_2.png height=500 width=500></a><figcaption class=image-caption>排序</figcaption></figure><blockquote><p>In the sorting phase, you start with the unitary arrays. During each step, you apply multiple merges and the overall cost is N=8 operations:</p><ul><li>In the first step you have 4 merges that cost 2 operations each</li><li>In the second step you have 2 merges that cost 4 operations each</li><li>In the third step you have 1 merge that costs 8 operations</li></ul><p>Since there are log(N) steps, the overall costs N * log(N) operations</p></blockquote><p>在排序阶段，从单个元素的数组开始。在每一步中你需要运行多次合并，并且总合并次数是 N=8 次：</p><ul><li>第一步需要进行 4 次合并，每次需要执行 2 次操作</li><li>第二步需要进行 2 次合并，每次需要执行 4 次操作</li><li>第三步需要执行 1 次合并，每次需要执行 8 次操作</li></ul><p>总共 log(N) 步，因此总开销是 <strong>N * log(N)</strong> 次操作。</p><h3 id=124-归并排序的强大之处>1.2.4 归并排序的强大之处</h3><blockquote><p>Why this algorithm is so powerful?</p></blockquote><p>为什么这个算法这么猛？</p><blockquote><p>Because:</p><ul><li>You can modify it in order to reduce the memory footprint, in a way that you don’t create new arrays but you directly modify the input array.</li></ul><p>Note: this kind of algorithms is called in-place.</p><ul><li>You can modify it in order to use disk space and a small amount of memory at the same time without a huge disk I/O penalty. The idea is to load in memory only the parts that are currently processed. This is important when you need to sort a multi-gigabyte table with only a memory buffer of 100 megabytes.</li></ul><p>Note: this kind of algorithms is called external sorting.</p><ul><li>You can modify it to run on multiple processes/threads/servers.
For example, the distributed merge sort is one of the key components of Hadoop (which is THE framework in Big Data).</li><li>This algorithm can turn lead into gold (true fact!).</li></ul></blockquote><p>因为：</p><ul><li>你可以通过一点修改来减少其内存开销，实现方式为不再创建新数组而是直接修改原数组。</li></ul><p>注：这种算法被称为<a href=https://en.wikipedia.org/wiki/In-place_algorithm target=_blank rel="noopener noreffer">就地算法</a></p><ul><li>你可以将其改为同时使用磁盘和一小部分内存的方式来避免磁盘IO的巨额开销。这种方式每次仅将当前正在处理的部分读入内存。当需要对一个几GB的大表排序，而内存缓存只有 100 MB时特别有用。</li></ul><p>注：这种算法称作<a href=https://en.wikipedia.org/wiki/External_sorting target=_blank rel="noopener noreffer">外部排序</a>。</p><ul><li>你可以将这个算法改成在多个处理器/线程/服务器上同时运行的。</li></ul><p>例如分布式归并排序就是<a href=https://hadoop.apache.org/docs/stable/api/org/apache/hadoop/mapreduce/Reducer.html target=_blank rel="noopener noreffer">Hadoop</a>(大数据框架)的一个关键组件。</p><ul><li>这种算法可以点石成金(触读的)</li></ul><blockquote><p>This sorting algorithm is used in most (if not all) databases but it’s not the only one. If you want to know more, you can read this research paper that discusses the pros and cons of the common sorting algorithms in a database.</p></blockquote><p>这个算法被用在大多数(但不是全部)数据库上，除了这个算法外还有其他的也被用到了。
如果了解更多关于排序算法在数据库中的应用，你可以读一下<a href=http://wwwlgis.informatik.uni-kl.de/archiv/wwwdvs.informatik.uni-kl.de/courses/DBSREAL/SS2005/Vorlesungsunterlagen/Implementing_Sorting.pdf target=_blank rel="noopener noreffer">这篇研究报告</a>，
在报告中讨论了数据库中常见的几种排序算法的优缺点。</p><h2 id=13-数组树和哈希表>1.3 数组，树和哈希表</h2><h3 id=131-数组>1.3.1 数组</h3><h3 id=132-树和数据库索引>1.3.2 树和数据库索引</h3><h3 id=133-哈希表>1.3.3 哈希表</h3><h1 id=2-全局概述>2 全局概述</h1><h1 id=3-客户端管理>3 客户端管理</h1><h1 id=4-查询管理>4 查询管理</h1><h2 id=41-查询解析>4.1 查询解析</h2><h2 id=42-查询重写>4.2 查询重写</h2><h2 id=43-统计信息>4.3 统计信息</h2><h2 id=44-查询优化器>4.4 查询优化器</h2><h3 id=441-索引>4.4.1 索引</h3><h3 id=442-访问路径>4.4.2 访问路径</h3><h3 id=443-联结操作>4.4.3 联结操作</h3><h3 id=444-简化的案例>4.4.4 简化的案例</h3><h3 id=445-动态规划贪心算法和启发式>4.4.5 动态规划、贪心算法和启发式</h3><h3 id=446-真正的优化器unimportant-part>4.4.6 真正的优化器(unimportant part)</h3><h3 id=447-查询计划缓存>4.4.7 查询计划缓存</h3><h2 id=45-查询执行>4.5 查询执行</h2><h1 id=5-数据管理>5 数据管理</h1><h2 id=51-缓存管理>5.1 缓存管理</h2><h3 id=511-预取>5.1.1 预取</h3><h3 id=512-缓存替换策略>5.1.2 缓存替换策略</h3><h3 id=513-写缓存>5.1.3 写缓存</h3><h2 id=52-事务管理>5.2 事务管理</h2><h3 id=521-酸了>5.2.1 酸了</h3><h3 id=522-并发控制>5.2.2 并发控制</h3><h3 id=523-锁管理>5.2.3 锁管理</h3><h3 id=524-日志管理>5.2.4 日志管理</h3><h1 id=6-总结>6 总结</h1></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-05-12</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/db/>db</a>,&nbsp;<a href=/tags/rdbms/>rdbms</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/cmu15445-db-storage/ class=prev rel=prev title=[note]数据库存储><i class="fas fa-angle-left fa-fw"></i>[note]数据库存储</a></div></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk></a>Gitalk</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.98.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>zh</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/gitalk/gitalk.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/css/befdf6.min.css><script type=text/javascript src=/lib/gitalk/gitalk.min.js></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{gitalk:{admin:["rustzzh"],clientID:"da0c5fc5ea73e5fd68b1",clientSecret:"b109d474223d93fb730ca7e01f2b4d0d63fcc60d",id:"2022-05-09T17:35:56+08:00",owner:"rustzzh",repo:"rustzzh.github.io",title:"[tran]关系型数据库原理"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>